<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=ns-m2xQYezAtqh7ai59hJbf4StG0Hm_q2rzPY0wvvg52HUEZEgyMHTxRy8a4hUrdPEgRjQ7SmZp8loyNcwuo40S781hFqMHj_gciLL2h846-jfeThp0NQsMQ1FNpPEEL');ol{margin:0;padding:0}table td,table th{padding:0}.c11{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Ubuntu";font-style:normal}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Ubuntu";font-style:normal}.c14{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Ubuntu Condensed";font-style:normal}.c9{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Ubuntu";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Ubuntu";font-style:normal}.c17{color:#000000;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Ubuntu Condensed";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;text-align:center}.c18{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:center}.c12{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c10{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c13{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;text-align:left}.c8{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c0{font-weight:400;font-family:"Droid Sans Mono"}.c1{color:inherit;text-decoration:inherit}.c5{color:#1155cc;text-decoration:underline}.c15{font-style:italic}.c4{height:11pt}.c16{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Ubuntu Condensed";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.subtitle{padding-top:0pt;color:#666666;font-size:18pt;padding-bottom:16pt;font-family:"Ubuntu Condensed";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}li{color:#000000;font-size:11pt;font-family:"Ubuntu"}p{margin:0;color:#000000;font-size:11pt;font-family:"Ubuntu"}h1{padding-top:20pt;color:#000000;font-weight:700;font-size:20pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#666666;font-size:18pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c8"><p class="c18 title" id="h.zdkp5m1b6848"><span>Web </span><span class="c16 c17">- Week 5</span></p><p class="c7 subtitle" id="h.4bczn7ey4uxc"><span class="c14">Images / Animation</span></p><p class="c3 c4"><span class="c2"></span></p><h1 class="c12" id="h.t2v0n8uwpyvu"><span class="c6">Review</span></h1><p class="c3"><span class="c2">Last week covered the basics of using the canvas. We started by creating the canvas element and drawing basic rectangles. Then, you drew more complex shapes such as arcs and ellipses and even created your own freeform drawings. Finally, some of your drew an image to the canvas.</span></p><h1 class="c12" id="h.cppg8l6p8hj4"><span class="c6">Images</span></h1><p class="c3"><span class="c2">If we&rsquo;re going to use the canvas to create a game, then we&rsquo;ll need to be able to draw images instead of just shapes. Well, drawing images is a little different than shapes, so let&rsquo;s get started with just one image.</span></p><h2 class="c10" id="h.svcpgn63q7r9"><span class="c9">Drawing an image</span></h2><h3 class="c13" id="h.vyxxct8rpmi6"><span>Exercise #1 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/NFTZEZG0&amp;sa=D&amp;ust=1486418330523000&amp;usg=AFQjCNHZIsb_oQ6vXcif3JTHzgLKWXymww">http://pastebin.com/NFTZEZG0</a></span></h3><p class="c3"><span class="c2">In order for this exercise to work on your system, you&rsquo;ll either need to rename an image to &ldquo;backdrop.png&rdquo; and place it in an &ldquo;images&rdquo; directory, or you&rsquo;ll have to change the backdrop.src to the location of your image.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>After refreshing your page, you&rsquo;ll see that you successfully set an image as the backdrop for your canvas. Looking at the code, you&rsquo;ll see that we don&rsquo;t simply call </span><span class="c0">drawImage</span><span class="c2">&nbsp;with our image&rsquo;s url. Instead, we need to create a new image element in JavaScript and set the source to our images location. Then, before we can go and draw the image, we need to wait for it to load. We wait for this event using an eventListener, just like we would with a click or submit event, then call our function to draw the image.</span></p><h2 class="c10" id="h.2i3xkpavm09"><span class="c9">Loading multiple images</span></h2><p class="c3"><span class="c2">Waiting for multiple images to load can get complicated really fast. One approach would be to nest each image load inside another, creating a mess of barely functional code. Another approach would be to have each load event set a &ldquo;loaded&rdquo; value on the image to true once it&rsquo;s loaded and have another function check at set intervals if every image is loaded. This approach is less of a mess, but still not ideal.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>Lucky for us, we aren&rsquo;t the first people to come across this issue in JavaScript, and there&rsquo;s already a solution - </span><span class="c16">promises</span><span>. We briefly worked with promises in the past when using the fetch function and calling &ldquo;then&rdquo; to use the data after it&rsquo;s been received. But in our case, </span><span class="c0">Image()</span><span class="c2">&nbsp;doesn&rsquo;t return a promise, so we&rsquo;ll have to make our own.</span></p><h3 class="c13" id="h.58kr8tcyy39t"><span>Exercise #2 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/yd83PFR5&amp;sa=D&amp;ust=1486418330531000&amp;usg=AFQjCNGp1rleoGbrdYECpQWVGANP959Rrg">http://pastebin.com/yd83PFR5</a></span></h3><p class="c3"><span class="c2">Loading up our page, we can see that we now have two images. That&rsquo;s great, but we added quite a bit of new code to achieve a seemingly simple feat. The good news is that with this code we can load and draw as many images as we want very easily.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>The main bit of new code here is the </span><span class="c0">createImageLoader</span><span>&nbsp;function. In this function we first create a new variable named l, and set it equal to an empty object. Next we create an images array (list in Python) on that object. Then we make a </span><span class="c0">loadImage</span><span class="c2">&nbsp;function. In this function, we create a new image and set the source to the given parameter. Next, instead of immediately adding a load event listener, we create a new promise.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span class="c2">This promise operates much like the fetch function. We&rsquo;re given two parameters, resolve and reject. Inside the promise we create two eventListeners, one for a successful load which will call resolve with the resulting image, and another for an error which calls reject with an error message.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>After adding the new promise to our array of images and returning the image itself to the caller, we create a new function &ldquo;</span><span class="c0">loadAll</span><span>&rdquo;. This function takes a list of promises and itself will &ldquo;resolve&rdquo; when </span><span class="c15">all</span><span class="c2">&nbsp;the promises have resolved. After this promise resolves we&rsquo;ll update our list of images to equal the loaded images, as well as catch any errors that occur and display them in the console.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>Finally, we create an instance of the ImageLoader and call loadImage on our two images. After loading the two images, we call &ldquo;loadAll&rdquo; and execute the </span><span class="c0">drawImages</span><span class="c2">&nbsp;function.</span></p><h2 class="c10" id="h.ctopyb5uppb8"><span class="c9">Giphy</span></h2><p class="c3"><span class="c2">That was a lot of new code, so let&rsquo;s take what we&rsquo;ve learned about images and create a Giphy image search out of it.</span></p><h3 class="c13" id="h.8x8iqh3x5i8o"><span>Exercise #3 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/2HR69cC9&amp;sa=D&amp;ust=1486418330543000&amp;usg=AFQjCNGOQl5x4MfywbAmf-Ei85mBvQ87ZA">http://pastebin.com/2HR69cC9</a></span></h3><p class="c3"><span class="c2">Unfortunately, because we&rsquo;re rendering the GIFs to the canvas, they aren&rsquo;t animated. However, we can still search for any term and see the first three results appear. You can now see how making our image loader a function instead of a singular object is useful, because we can easily create a new loader for each query.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span class="c2">Try modifying the size and position of the drawn images to show four or more results on the canvas.</span></p><h1 class="c12" id="h.cn1050rafjof"><span class="c6">Character</span></h1><p class="c3"><span>We&rsquo;ve now successfully loaded and drawn multiple images to the screen, so let&rsquo;s take that knowledge and apply it to our game.</span></p><h3 class="c13" id="h.9biujyz9188"><span>Exercise #4 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/Y5aA10mW&amp;sa=D&amp;ust=1486418330549000&amp;usg=AFQjCNG_rQMbbQJ885-PU6jIrW5pX23EPQ">http://pastebin.com/Y5aA10mW</a></span></h3><p class="c3"><span>In this exercise, we make a new </span><span class="c0">createPlayer</span><span>&nbsp;function which we&rsquo;ll use to create the player object. First, </span><span class="c0">createPlayer</span><span>&nbsp;declares </span><span class="c0">p</span><span>&nbsp;to be a new object and then assigns all the necessary variables such as the image, scale, dimensions, and position. We then create two functions on the object, the first of which does nothing right now, and the second which draws the image, then returns the current position and dimensions. Finally, </span><span class="c0">createPlayer</span><span>&nbsp;returns the p object it&rsquo;s created.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>The next interesting part in this exercise is the </span><span class="c0">gameLoop</span><span>&nbsp;and subsequent </span><span class="c0">update</span><span>&nbsp;and </span><span class="c0">draw</span><span>&nbsp;functions it calls. We start and continue running the game loop by calling </span><span class="c0">requestAnimationFrame</span><span class="c2">. This function is controlled by the browser and will aim to call our game loop sixty times per second, but will slow down according to how fast it can update the window.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span class="c2">Lastly we have the draw function, which draws the player, along with filling each previously drawn area with a white rectangle. An alternative to drawing a white rectangle over the last drawn area would be clearing the entire canvas. However, this is much less efficient and would cause more frame lag, especially on the Raspberry Pi.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span class="c2">Try using the console to change the position and size of your player.</span></p><h2 class="c10" id="h.rrp0p8nqm82h"><span class="c9">Animations</span></h2><p class="c3"><span class="c2">Now that we have a player object, let&rsquo;s begin animating it.</span></p><h3 class="c13" id="h.69om78v88lkr"><span>Exercise #5 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/cmrYB6ua&amp;sa=D&amp;ust=1486418330560000&amp;usg=AFQjCNHJF_3KDficE4qkUd2VyLc2KtbgIQ">http://pastebin.com/cmrYB6ua</a></span></h3><p class="c3"><span class="c2">Animating our player adds in quite a bit of new code, so let&rsquo;s review the major parts.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>First, we have the </span><span class="c0">createAnimation</span><span class="c2">&nbsp;function which takes in a name, path, length (of animation), time (per frame), and an optional loop parameter. In this function, we create a new object which in turn creates another object with the given name. We then make an array named &ldquo;frames&rdquo;, which is filled with each image of the animation returned by our image loader. On the last few lines, we add the frameTime and loop parameters as variables on the object and return said object.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>Next, we declare a </span><span class="c0">playerAnimations</span><span>&nbsp;variables which uses the </span><span class="c0">Object.assign</span><span>&nbsp;method. </span><span class="c0">Object.assign</span><span>&nbsp;will take all the objects passed in and combine them with the first object we give it, which is just an empty object in our case. Therefore, </span><span class="c0">playerAnimations</span><span>&nbsp;is equal to an object with properties for each animations which contains all relevant information we provided in the </span><span class="c0">createAnimation</span><span class="c2">&nbsp;function.</span></p><p class="c3 c4"><span class="c2"></span></p><p class="c3"><span>Finally, we update the createPlayer function with an </span><span class="c0">updateAnimation</span><span>&nbsp;method which will loop through all the frames of the current animation.</span></p><h3 class="c13" id="h.s7nw8zb2bt8s"><span>Exercise #6 - </span><span class="c5"><a class="c1" href="https://www.google.com/url?q=http://pastebin.com/y4T317fe&amp;sa=D&amp;ust=1486418330567000&amp;usg=AFQjCNGZFxGkA-g9yf8EddooicEPSXPjtg">http://pastebin.com/y4T317fe</a></span></h3><p class="c3"><span>In this last exercise we create a function which takes care of all the variables involved with changing the state (and therefore animation) of our player. You can now easily call this function from the console to change the player&rsquo;s state.</span></p></body></html>